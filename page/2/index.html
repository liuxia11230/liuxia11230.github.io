<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-前端安全防范" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/07/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83/" class="article-date">
  <time class="dt-published" datetime="2020-05-07T07:39:04.000Z" itemprop="datePublished">2020-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/07/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83/">前端安全防范</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着互联网的迅速发展，个大企业越来越重视安全性问题，这时前端人员要面对传统的 XSS,CSRF 等安全性问题之外还有，网络劫持的新型安全性问题。当然<br>随着各大浏览器的崛起他们也在自身中加强了安全防范意识。</p>
<h2 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h2><blockquote>
<p>Cross-Site Scripting(跨站脚本攻击)为了和 css 区分于是缩写名称为 XSS。<br>通过目标网站上注入恶意代码，使之在浏览器上面运行。攻击者可获取用户的敏感信息如 cookie，SessionID 等。<br>就算输入长度收到了限制，他可以引入外部脚本，并由浏览器执行，来完成比较复杂的攻击</p>
</blockquote>
<h2 id="XSS-分类"><a href="#XSS-分类" class="headerlink" title="XSS 分类"></a>XSS 分类</h2><p>储存型、反射型、DOM 型</p>
<h3 id="储存型"><a href="#储存型" class="headerlink" title="储存型"></a>储存型</h3><p>1.攻击者将恶意代码提交到数据库中 2.用户再次打开用户网站是读取数据中的数据，通过浏览器执行恶有代码 3.恶意代码可窃取用户数据，或者冒充用户行为调用接口执行一些操作</p>
<p>常出现在保存数据的网站中，如商品评论等。</p>
<h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>1.用户构造出恶意的 URL，服务端从 URL 中读取数据，服务端经过操作在返回给浏览器。执行。</p>
<p>储存行、反射型的区别是，一个存数据库，一个存 URL<br>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。<br>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。<br>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p>
<h3 id="DOM-型"><a href="#DOM-型" class="headerlink" title="DOM 型"></a>DOM 型</h3><p>1.用户构造出恶意的 URL，用户大开 URL，前端从 URL 中读取数据，恶意代码开始执行。</p>
<blockquote>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 ?&gt;XSS 都属于服务端的安全漏洞。<a target="_blank" rel="noopener" href="http://localhost:8080/dvwa/%3E">http://localhost:8080/dvwa/&gt;</a> vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D;English”<script>alert(1)"</script></p>
</blockquote>
<h2 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h2><p>xss 攻击的本质是</p>
<ul>
<li>攻击者提交恶意代码</li>
<li>浏览器执行恶意代码</li>
</ul>
<p>那么前端过滤用户输入行吗？当然是不行的，要是攻击者直接构造请求绕过前端过滤，也是不行的。</p>
<h3 id="CSRF-cross-site-quest-forgery-跨站点请求伪造攻击"><a href="#CSRF-cross-site-quest-forgery-跨站点请求伪造攻击" class="headerlink" title="CSRF cross-site-quest-forgery(跨站点请求伪造攻击)"></a>CSRF cross-site-quest-forgery(跨站点请求伪造攻击)</h3><blockquote>
<p>原理：发生在 2 个网站之间， 目标网站 A，攻击网站 B，当你访问过 A 后已经拿到目标网站的一些认证，比如你登录过后，不小心进入 B 网站，诱导你点击一些请求链接，此时像你的服务其发起请求，造成攻击；</p>
</blockquote>
<blockquote>
<p>解决：验证码，token，检查 http 请求头中的 referer,请求的来源地址</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/07/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83/" data-id="cltzhcyde0013zoxh9xcs3apw" data-title="前端安全防范" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-webpack详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/07/webpack%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2020-05-07T06:53:55.000Z" itemprop="datePublished">2020-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/07/webpack%E8%AF%A6%E8%A7%A3/">webpack详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/07/webpack%E8%AF%A6%E8%A7%A3/" data-id="cltzhcydc000vzoxh0aoab6d6" data-title="webpack详解" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-js运行核心-事件循环（Event-Loop）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/29/js%E8%BF%90%E8%A1%8C%E6%A0%B8%E5%BF%83-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2020-04-29T01:55:49.000Z" itemprop="datePublished">2020-04-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/javascript/">javascript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/29/js%E8%BF%90%E8%A1%8C%E6%A0%B8%E5%BF%83-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89/">js运行核心-事件循环（Event-Loop）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Event-Loop-是如何诞生的？"><a href="#Event-Loop-是如何诞生的？" class="headerlink" title="Event-Loop 是如何诞生的？"></a>Event-Loop 是如何诞生的？</h2><blockquote>
<p>由于 js 是单线程的，对于网页脚本多线程对显得很复杂，而且可能执行结果会相互影响，对于 dom 的显示不太友好，那么单线程就一定会造成阻塞，为了解决这个问题 Event-Loop 诞生了。<br>js 也分为同步和异步，而异步是不会阻塞主线程的运行的，他会等待主线程的代码执行完毕。</p>
</blockquote>
<h2 id="了解程序、进程、线程"><a href="#了解程序、进程、线程" class="headerlink" title="了解程序、进程、线程"></a>了解程序、进程、线程</h2><ul>
<li>程序：程序是静态的，一个程序包含多个进程</li>
<li>进程：相当于工厂，进程让程序动态化了（cpu&lt;承担所有计算任务&gt;资源分配的最小单位）</li>
<li>线程：相当于工厂的工人，一个进程有多个线程</li>
</ul>
<h2 id="浏览器是多进程"><a href="#浏览器是多进程" class="headerlink" title="浏览器是多进程"></a>浏览器是多进程</h2><ul>
<li>主进程</li>
</ul>
<ul>
<li>协调其他子进程（创建、销毁）</li>
<li>处理不可见操作，网络呢请求，文件访问</li>
</ul>
<ul>
<li>第三方插件进程</li>
<li>GPU</li>
</ul>
<ul>
<li>绘制 3D</li>
</ul>
<ul>
<li>渲染进程，也就是浏览器内核</li>
</ul>
<h2 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h2><p>对于渲染进程来说也是多线程的</p>
<ul>
<li>CUI 渲染线程</li>
</ul>
<ul>
<li>负责渲染页面，布局和绘制</li>
<li>页面需要吗重绘和回流的时候</li>
<li>与 js 引擎互斥，防止渲染结果不可预期</li>
</ul>
<ul>
<li>js 引擎线程</li>
</ul>
<ul>
<li>负责解析和执行 javascript</li>
<li>只有一个 js 引擎（单线程）</li>
<li>GUI 线程互斥</li>
</ul>
<ul>
<li>事件触发线程</li>
</ul>
<ul>
<li>用来控制事件循环</li>
</ul>
<ul>
<li><p>定时触发线程</p>
</li>
<li><p>异步 http 请求线程</p>
</li>
</ul>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>js 中的内存分为 堆内存(heap) 和 栈内存(stack), 堆内存 中存的是我们声明的 object 类型的数据，栈内存 中存的是 基本数据类型 以及 函数执行时的运行空间。我们的 同步 代码就放在 执行栈 中，那异步代码呢？浏览器会将 dom 事件 ajax setTimeout 等异步代码放到队列中，等待执行栈中的代码都执行完毕，才会执行队列中的代码，是不是有点像发布订阅模式。<br>这是因为 异步分为 微任务(microtask) 和 宏任务(task)，执行的顺序是 执行栈中的代码 &#x3D;&gt; 微任务 &#x3D;&gt; 宏任务。</p>
<h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈中的代码永远最先执行</p>
<h2 id="微任务-microtask-promise-MutationObserver…"><a href="#微任务-microtask-promise-MutationObserver…" class="headerlink" title="微任务(microtask): promise MutationObserver…"></a>微任务(microtask): promise MutationObserver…</h2><p>当执行栈中的代码执行完毕，会在执行宏任务队列之前先看看微任务队列中有没有任务，如果有会先将微任务队列中的任务清空才会去执行宏任务队列</p>
<h2 id="宏任务-task-setTimeout-setInterval-setImmediate-IE-专用-messageChannel…"><a href="#宏任务-task-setTimeout-setInterval-setImmediate-IE-专用-messageChannel…" class="headerlink" title="宏任务(task): setTimeout setInterval setImmediate(IE 专用) messageChannel…"></a>宏任务(task): setTimeout setInterval setImmediate(IE 专用) messageChannel…</h2><p>等待执行栈和微任务队列都执行完毕才会执行，并且在执行完每一个宏任务之后，会去看看微任务队列有没有新添加的任务，如果有，会先将微任务队列中的任务清空，才会继续执行下一个宏任务</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/29/js%E8%BF%90%E8%A1%8C%E6%A0%B8%E5%BF%83-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89/" data-id="cltzhcyd5000czoxhbd2x6qrk" data-title="js运行核心-事件循环（Event-Loop）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue3-没有采用-Fiber" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/24/Vue3-%E6%B2%A1%E6%9C%89%E9%87%87%E7%94%A8-Fiber/" class="article-date">
  <time class="dt-published" datetime="2020-04-24T06:17:23.000Z" itemprop="datePublished">2020-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/24/Vue3-%E6%B2%A1%E6%9C%89%E9%87%87%E7%94%A8-Fiber/">Vue3 没有采用 Fiber</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="vue3-0的主要突破点"><a href="#vue3-0的主要突破点" class="headerlink" title="vue3.0的主要突破点"></a>vue3.0的主要突破点</h2><ul>
<li>performance:性能更强</li>
<li>Tree shaking支持：打包时不会将未使用模块打包</li>
<li>组合API（Composition API）</li>
<li>Fragment(不再限制只有根节点，甚至可以是纯文本，会自动变成一个Fragments碎片)</li>
<li>Teleport, </li>
<li>Suspense()</li>
<li>Better TypeScript support：更优秀的Ts支持</li>
<li>Custom Renderer API：暴露了自定义渲染API</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p> 模版编译优化</p>
<blockquote>
<p>在生成virtual dom的时候，静态节点将会在diff算法直接跳过对比，而动态节点在creat后会有一个pacthFlg，js在runtime的时候将会跟踪pachFlg的节点。<br>pathFlg的美枚举定义</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export const enum PatchFlags &#123;</span><br><span class="line">  </span><br><span class="line">  TEXT = 1,// 表示具有动态textContent的元素</span><br><span class="line">  CLASS = 1 &lt;&lt; 1,  // 表示有动态Class的元素</span><br><span class="line">  STYLE = 1 &lt;&lt; 2,  // 表示动态样式（静态如style=&quot;color: red&quot;，也会提升至动态）</span><br><span class="line">  PROPS = 1 &lt;&lt; 3,  // 表示具有非类/样式动态道具的元素。</span><br><span class="line">  FULL_PROPS = 1 &lt;&lt; 4,  // 表示带有动态键的道具的元素，与上面三种相斥</span><br><span class="line">  HYDRATE_EVENTS = 1 &lt;&lt; 5,  // 表示带有事件监听器的元素</span><br><span class="line">  STABLE_FRAGMENT = 1 &lt;&lt; 6,   // 表示其子顺序不变的片段（没懂）。 </span><br><span class="line">  KEYED_FRAGMENT = 1 &lt;&lt; 7, // 表示带有键控或部分键控子元素的片段。</span><br><span class="line">  UNKEYED_FRAGMENT = 1 &lt;&lt; 8, // 表示带有无key绑定的片段</span><br><span class="line">  NEED_PATCH = 1 &lt;&lt; 9,   // 表示只需要非属性补丁的元素，例如ref或hooks</span><br><span class="line">  DYNAMIC_SLOTS = 1 &lt;&lt; 10,  // 表示具有动态插槽的元素</span><br><span class="line">  // 特殊 FLAGS -------------------------------------------------------------</span><br><span class="line">  HOISTED = -1,  // 特殊标志是负整数表示永远不会用作diff,只需检查 patchFlag === FLAG.</span><br><span class="line">  BAIL = -2 // 一个特殊的标志，指代差异算法（没懂）</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过patchFlg可以判断动态节点中修改的属性，没有涉及到的可以不用考虑。</p>
<p><img src="/images/E07F20C3-AE56-4841-86E0-E6316C9F7614.png" alt="blockchain" title="图"></p>
<p>上图所示vue3.0的diff算法中不会对比静态节点。</p>
<h3 id="静态提升"><a href="#静态提升" class="headerlink" title="静态提升"></a>静态提升</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const _hoisted_1 = &#123; id: &quot;app&quot; &#125;</span><br><span class="line">const _hoisted_2 = _createVNode(&quot;h1&quot;, null, &quot;技术摸鱼&quot;, -1 /* HOISTED */)</span><br><span class="line">const _hoisted_3 = _createVNode(&quot;p&quot;, null, &quot;今天天气真不错&quot;, -1 /* HOISTED */)</span><br><span class="line"></span><br><span class="line">export function render(_ctx, _cache) &#123;</span><br><span class="line">  return (_openBlock(), _createBlock(&quot;div&quot;, _hoisted_1, [</span><br><span class="line">    _hoisted_2,</span><br><span class="line">    _hoisted_3,</span><br><span class="line">    _createVNode(&quot;div&quot;, null, _toDisplayString(_ctx.name), 1 /* TEXT */),</span><br><span class="line">    _createVNode(&quot;div&quot;, &#123;</span><br><span class="line">      class: &#123;red:_ctx.isRed&#125;</span><br><span class="line">    &#125;, &quot;摸鱼符&quot;, 2 /* CLASS */)</span><br><span class="line">  ]))</span><br></pre></td></tr></table></figure>
<p>就是把静态节点但是提出来，这样在创建virtual dom的时候不会重复去创建子节点（对于内存会有提升）</p>
<h3 id="事件监听缓存"><a href="#事件监听缓存" class="headerlink" title="事件监听缓存"></a>事件监听缓存</h3><blockquote>
<p>vue3.0中会尽量去判断你绑定的方法是否会有改变，如果没有改变将会把该方法进行缓存，不会在dom更新的时候重新绑定方法。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export function render(_ctx, _cache) &#123;</span><br><span class="line">  return (_openBlock(), _createBlock(&quot;div&quot;, null, [</span><br><span class="line">    _createVNode(&quot;span&quot;, &#123;</span><br><span class="line">      onClick: _cache[1] || (_cache[1] = $event =&gt; (_ctx.onClick($event)))</span><br><span class="line">    &#125;, _toDisplayString(_ctx.msg), 1 /* TEXT */)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ssr"><a href="#ssr" class="headerlink" title="ssr"></a>ssr</h3><blockquote>
<p>他会把所有的节点看成是一个是字符串</p>
</blockquote>
<h3 id="vue3-0为什么不用fiber呢"><a href="#vue3-0为什么不用fiber呢" class="headerlink" title="vue3.0为什么不用fiber呢"></a>vue3.0为什么不用fiber呢</h3><p>vue的proxy+vdom+静态标记，已经把任务做到很细了，所以也不太需要事件切片了（time-slice）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/24/Vue3-%E6%B2%A1%E6%9C%89%E9%87%87%E7%94%A8-Fiber/" data-id="cltzhcyd30007zoxh06w8bgps" data-title="Vue3 没有采用 Fiber" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Fiber-架构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/24/Fiber-%E6%9E%B6%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2020-04-24T01:09:11.000Z" itemprop="datePublished">2020-04-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/24/Fiber-%E6%9E%B6%E6%9E%84/">Fiber 架构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="为什么会采用fiber"><a href="#为什么会采用fiber" class="headerlink" title="为什么会采用fiber"></a>为什么会采用fiber</h2><p>vue3.0采用了静态标记+方法缓存去优化了他的diff，二react采用了fiber</p>
<h2 id="react中的fiber"><a href="#react中的fiber" class="headerlink" title="react中的fiber"></a>react中的fiber</h2><p>react的UI卡顿主要是diff造成的，那么就从diff上下手，于是react走了cpu调度逻辑，把virtual dom 微观上变成了链表结构，利用浏览器空闲事件做diff，超过16ms，如果有优先级高的任务（动画，交互）就把执行权交给浏览器。等空闲了继续执行。</p>
<p><img src="/images/A873DC80-FB0F-4C2C-86D0-87A1BC1F565F.png" alt="blockchain" title="图"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">requestIdelCallback(myNonEssentialWork);</span><br><span class="line">// 等待女神空闲</span><br><span class="line">function myNonEssentialWork (deadline)liuxia1 &#123;</span><br><span class="line">    // deadline.timeRemaining()&gt;0 主线程女神还有事件</span><br><span class="line">    // 还有diff任务没算玩</span><br><span class="line">    while (deadline.timeRemaining() &gt; 0 &amp;&amp; tasks.length &gt; 0) &#123;</span><br><span class="line">    doWorkIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">    // 女神没时间了，把女神还回去🤣</span><br><span class="line">    if (tasks.length &gt; 0)&#123;</span><br><span class="line">        requestIdleCallback(myNonEssentialWork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/24/Fiber-%E6%9E%B6%E6%9E%84/" data-id="cltzhcycv0001zoxh4n78hxuj" data-title="Fiber 架构" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-react面试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/07/react%E9%9D%A2%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2019-11-07T06:56:23.000Z" itemprop="datePublished">2019-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/07/react%E9%9D%A2%E8%AF%95/">react 面试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="react-篇"><a href="#react-篇" class="headerlink" title="react 篇"></a>react 篇</h2><h3 id="1-react-生命周期是怎样的"><a href="#1-react-生命周期是怎样的" class="headerlink" title="1.react 生命周期是怎样的"></a>1.react 生命周期是怎样的</h3><blockquote>
<p>一、初始化阶段<br>getDefaultProps:获取默认属性<br>getInitailState:获取初始化状态<br>componentWillMount:组建即将被挂在页面上，即将渲染。<br>render:组建在这里生成虚拟 Dom 节点<br>componentDidMount:组建真正被挂载</p>
</blockquote>
<blockquote>
<p>二、组建运行时<br>componetWillReceiveProps:组建接收到属性的时候调用<br>shouldCompontUpdata:组建状态发生变化时（设为 false 可以不用更新视图，在次阶段进行优化）<br>compontWillUpdata:组建即将更新，不能修改其状态和属性了<br>render:组建重新描绘<br>componentDidUpdata:组建已经更新了</p>
</blockquote>
<blockquote>
<p>三、销毁阶段<br>componWillUnmount:组建即将销毁</p>
</blockquote>
<h3 id="2-react-hook-实现生命周期"><a href="#2-react-hook-实现生命周期" class="headerlink" title="2.react hook 实现生命周期"></a>2.react hook 实现生命周期</h3><blockquote>
<ol>
<li>函数组建没有构造函数不能没有实例话，通过 useState 初始化</li>
<li>componetDidMount ｜ componetDidUpdata ｜ componetWillUnMount</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line">  return ()=&gt;&#123;</span><br><span class="line">    //卸载是运行</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,[])</span><br><span class="line">//componetDidUpdata</span><br><span class="line">useEffect(()=&gt;&#123;</span><br><span class="line">  return ()=&gt;&#123;</span><br><span class="line">    //卸载是运行</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-Element-和-componet-区别"><a href="#3-Element-和-componet-区别" class="headerlink" title="3.Element 和 componet 区别"></a>3.Element 和 componet 区别</h3><blockquote>
<p>Element 是 UI 的一种表示。Compont 是一个类或者函数可以接收和返回一个 Element</p>
</blockquote>
<h3 id="4-pureComponet-与-Componet-的区别"><a href="#4-pureComponet-与-Componet-的区别" class="headerlink" title="4.pureComponet 与 Componet 的区别"></a>4.pureComponet 与 Componet 的区别</h3><blockquote>
<p>pureCompont 中 state 和 props 是浅对比来实现 shouldComponetUpdata()。但是数据层次过深坑监听不到变化从未不会更新视图<br>扩展：浅比较。Object.js()诞生<br>传统的&#x3D;&#x3D;会把 undefined,null,’’,0 转化为 boolean<br>&#x3D;&#x3D;&#x3D; +0 &#x3D;&#x3D;&#x3D; -0)(true) 期待返回 false<br>NaN&#x3D;&#x3D;&#x3D;NaN(false) 期待返回 ture</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">function is(A,B)&#123;</span><br><span class="line">  if(x===y)&#123;</span><br><span class="line">    //1/-0=-Infinity</span><br><span class="line">    //1/0=Infinity</span><br><span class="line">    //-0==0(true)</span><br><span class="line">    return A!==0||B!==0||1/A===1/B</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return A!==A &amp;&amp; B!==B</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用原型链的方法</span><br><span class="line">const hasOwn = Object.prototype.hasOwnProperty</span><br><span class="line"></span><br><span class="line">// 这个函数实际上是Object.is()的polyfill</span><br><span class="line">function is(x, y) &#123;</span><br><span class="line">  if (x === y) &#123;</span><br><span class="line">    return x !== 0 || y !== 0 || 1 / x === 1 / y</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return x !== x &amp;&amp; y !== y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function shallowEqual(objA, objB) &#123;</span><br><span class="line">  // 首先对基本数据类型的比较</span><br><span class="line">  // !! 若是同引用便会返回 true</span><br><span class="line">  if (is(objA, objB)) return true</span><br><span class="line">  // 由于Obejct.is()可以对基本数据类型做一个精确的比较， 所以如果不等</span><br><span class="line">  // 只有一种情况是误判的，那就是object,所以在判断两个对象都不是object</span><br><span class="line">  // 之后，就可以返回false了</span><br><span class="line">  if (typeof objA !== &#x27;object&#x27; || objA === null ||</span><br><span class="line">      typeof objB !== &#x27;object&#x27; || objB === null) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 过滤掉基本数据类型之后，就是对对象的比较了</span><br><span class="line">  // 首先拿出key值，对key的长度进行对比</span><br><span class="line">  const keysA = Object.keys(objA)</span><br><span class="line">  const keysB = Object.keys(objB)</span><br><span class="line"></span><br><span class="line">  // 长度不等直接返回false</span><br><span class="line">  if (keysA.length !== keysB.length) return false</span><br><span class="line">  // key相等的情况下，在去循环比较</span><br><span class="line">  for (let i = 0; i &lt; keysA.length; i++) &#123;</span><br><span class="line">  // key值相等的时候</span><br><span class="line">  // 借用原型链上真正的 hasOwnProperty 方法，判断ObjB里面是否有A的key的key值</span><br><span class="line">  // 属性的顺序不影响结果也就是&#123;name:&#x27;daisy&#x27;, age:&#x27;24&#x27;&#125; 跟&#123;age:&#x27;24&#x27;，name:&#x27;daisy&#x27; &#125;是一样的</span><br><span class="line">  // 最后，对对象的value进行一个基本数据类型的比较，返回结果</span><br><span class="line">    if (!hasOwn.call(objB, keysA[i]) ||</span><br><span class="line">        !is(objA[keysA[i]], objB[keysA[i]])) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：浅比较只比较了最外一层，key 的长度，b 是否存在 Key 以及值是否相等</p>
</blockquote>
<h3 id="key-值的作用"><a href="#key-值的作用" class="headerlink" title="key 值的作用"></a>key 值的作用</h3><blockquote>
<p>DOM 元素进行复用，当 key 值一样的时候，节点不会重新被创建，当 key 位置不同时，只是移动作用。提高 diff 算法的实现方式。key 只好是稳定，可预测的，唯一的</p>
</blockquote>
<h3 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/07/react%E9%9D%A2%E8%AF%95/" data-id="cltzhcyd8000jzoxhfnxb9wxk" data-title="react 面试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-webgis开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/07/webgis%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2019-11-07T06:56:23.000Z" itemprop="datePublished">2019-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/gis/">gis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/07/webgis%E5%BC%80%E5%8F%91/">cesuim 开发基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="gis"><a href="#gis" class="headerlink" title="gis"></a>gis</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/07/webgis%E5%BC%80%E5%8F%91/" data-id="cltzhcydb000szoxhaosl65pu" data-title="cesuim 开发基础" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gis/" rel="tag">gis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-浏览器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/07/%E6%B5%8F%E8%A7%88%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2019-11-07T06:56:23.000Z" itemprop="datePublished">2019-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/07/%E6%B5%8F%E8%A7%88%E5%99%A8/">react 面试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h2><p>HTTP 缓存：</p>
<blockquote>
<p>1.强缓存，利用 http 头中的 expries（到期）和 cache-control 来控制，当请求再次发生的时候浏览器会根这两个参数判断，不回再次以服务器发生通信<br>返回码 200 （from disk cache）<br>cache-control 可以替代 expries（用它的目的就是向下兼容）</p>
</blockquote>
<blockquote>
<p>cache-control: max-age&#x3D;3600, s-maxage&#x3D;31536000 有效期多久<br>public 与 private<br>public 能被服务器和浏览器缓存，private 只能被浏览器缓存<br>no-store 与 no-cache 前者绕开所有缓存直接请求服务器后者像服务器确认是否过期</p>
</blockquote>
<blockquote>
<p>2.协商缓存，依赖于浏览器和服务器之间的通信 返回 304 not modified 表示资源未被修改，这是会重定向到浏览器缓存<br>Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：<br>Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT</p>
</blockquote>
<blockquote>
<p>随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：<br>If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/07/%E6%B5%8F%E8%A7%88%E5%99%A8/" data-id="cltzhcydf0018zoxh10xl9e2w" data-title="react 面试" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-常见面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/11/07/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2019-11-07T06:22:11.000Z" itemprop="datePublished">2019-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/js/">js</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/11/07/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">常见知识点链接</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h5 id="常见知识点链接-1"><a href="#常见知识点链接-1" class="headerlink" title="常见知识点链接 1"></a><a target="_blank" rel="noopener" href="https://juejin.im/post/6880028535101227021" title="常见知识点链接1">常见知识点链接 1</a></h5><p>前端来自真实大厂的 532 道面试题<br>2018.09.20 14:08 14855 浏览<br>一、来源背景<br>面试题是来自微博@牛客网发布的真实大厂前端面经题目，我一直在收集题目长期一个一个的记录下来的，可能会有重复，但基本前端的面试大纲和需要掌握的知识都在其中了，面试题仅做学习参考，学习者阅后也要用心钻研其中的原理，重要知识需要系统学习、透彻学习，形成自己的知识链。</p>
<p>二、532 道前端真实大厂面试题<br>express 和 koa 的对比，两者中间件的原理，koa 捕获异常多种情况说一下<br>你项目里用到第三方登录涉及的 oAuth(JWT)协议的实现原理，以及你本地的实现原理，第三方登录怎么样保证安全性<br>说下快排完整性<br>react 和 vue 的区别，你开发如何选择技术栈<br>express 里面登录的 session 服务怎么样实现分布式服务<br>vue 的理解<br>vue 的双向数据绑定的原理<br>vue 怎么样实现数组绑定<br>js 的继承<br>call 和 apply 的区别<br>ajax 是同步还是异步，怎么样实现同步<br>ajax 实现过程<br>闭包的作用理解，以及那些地方用过闭包，以及闭包的缺点，如何实现闭包<br>跨域方法以及怎么样实现的与原理<br>工作中做的项目有什么亮点<br>webpack 工程构建工具怎么样用<br>数组去重<br>快排和冒泡原理<br>http 状态码<br>nodejs 了解多少<br>为什么 css 样式初始化，目的是为了什么<br>为什么浏览器会产生同源策略<br>axios 有什么特点<br>cookie 和 webstrage 的区别以及 cookie 怎么样使用？原生 cookie 怎么样封装<br>三次握手<br>对跨域了解吗。jsonp 的限制<br>浏览器那些地方用到了异步<br>css 弹性布局，那些地方用到过<br>position 属性有哪些值，分别有什么含义<br>ES6 用过吗，新增了那些东西，你用到过什么<br>const 和 let 的区别，可以改变 const 定义对象某个属性吗<br>箭头函数，箭头函数的特点<br>js 的 this 理解， 如何改变 this 的指向<br>cookie 有什么限制<br>js 的事件机制<br>settimeout 的机制<br>遇到过兼容性的问题吗，要如何处理<br>项目中使用过构建工具吗<br>平时如何学习前端的，最近在看的一本书<br>内存泄露的排除定位和解决方法<br>垃圾回收机制<br>websocket 实现原理<br>http 状态码 301 302 的区别，304 是啥<br>缓存机制，协商协议<br>定时器 setTimeout 的运行机制<br>事件循环机制 eventloop<br>异步 es5 es6 es7 分别怎么样解决<br>js 的继承的实现方法<br>清除浮动的方法<br>常见布局的方法<br>从输入一个 url 到浏览器页面展示都经历了哪些过程<br>new 生成了一个对象的过程（核心 return this）<br>请简单说明什么是事件冒泡和事件捕获以及事件委托<br>实现一个两边宽度固定中间自适应的三列布局，圣杯布局，双飞燕<br>flex 布局有没有了解<br>请简述一下 js 原型链<br>es6 有了解吗，请简单说一下 promise 机制，异步的承诺机制，顺势说一下解决回调地狱的问题<br>手写一下深拷贝，答案提示：JSON.parse(JSON.stringify(obj)) 用 JSON 实现深拷贝<br>&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的却别，，typeof null 的结果是什么<br>同步和异步的执行顺序<br>get 和 post 的请求区别<br>什么情况算是跨域，如何解决跨域问题<br>一个有序的数组如何进行查找操作<br>手写一个快速排序<br>事件委托理解，原理，好处，应用场景<br>前端框架用过什么？<br>vue 和 react 的区别<br>vue 的原理<br>闭包<br>let 和 var 的区别，let 的产生背景？<br>定宽定高，如何垂直居中，那不定宽定高呢？<br>https 的请求过程<br>代码规范<br>项目中遇到过什么难点，如何解决的<br>尾递归问题<br>电脑里有很多大小不一样的照片，我现在要复制到 U 盘上，但是 U 盘容量固定，让你写一个程序，挑选一组照片，让 U 盘的剩余空间最小。<br>后端会哪些语言<br>讲下如何负载均衡<br>cookie 和 session 的区别和联系<br>nodejs 是单线程还是多线程的，为什么能去开很多异步请求去访问其他接口<br>一般你是如何操作数据库的？会哪些数据库<br>mysql 的底层引擎，发布<br>mysql 语言写的如何，怎么样判断 sql 语句的性能？如何优化？<br>如何去除数组中的重复的项？<br>遍历数组处理用 for 循环还有什么方法吗<br>浏览器出于安全考虑有？（同源策略）<br>登录原理<br>让我设计一个页面，选择男或女，搜索出相对性<br>发送请求有哪些？<br>web 的安全问题？<br>自我介绍<br>JS 如何计算浏览器的渲染时间的<br>浏览器的缓存<br>var 的变量提升底层原理是什么？<br>event loop 讲讲<br>JS 的回收机制说一下<br>数组常用的方法有哪些<br>websock 的底层原理讲讲<br>你的聊天室项目，如果数据传输出错了怎么办？<br>现在有一大段文字，如何在页面中设置一个窗口滚动播出这段文件（轮播），轮播图如何解决卡顿问题，有手写过轮播图你，原理是什么<br>垂直水平居中的方式<br>实现三栏布局，中间自适应有几种方法<br>算法：给你一个无序数字数组，里面是随机的书，并给出一个目标值，求这个数组的两个数，这个数的和等于目标值，要求这两个数并给出下标，你能想到最优的办法是什么吗（提示：快排，双指针）<br>算法：给一个无序的数组，让我分割成 m 组，这个 m 组里和最大的一组是所有可能的分割情况最小的（二分答案法）<br>webpack 的原理<br><em>proto</em> 和 prototype 分别是什么<br>原型链原理<br>在原型链上 Object 再往上是什么<br>new 和 Object.create 的区别<br>哪种情况下<strong>proto</strong>和 prototype 的指向是同一个？<br>typeof array null undefined NaN 分别是什么<br>把 undefined 和 null 转成 Number 分别是什么<br>如何判断是否为数组？（instanceOf 和 constructor 可以，但是有原型链断裂的风险，Object.toString.call()最稳定）<br>instanceOf 和 constructor 的区别<br>原型链断裂了以后的结果是什么<br>如果让你实现一个 promise 怎么样实现<br>如何学前端的，看了哪些书<br>博客写了多少篇<br>你的技术亮点在哪里<br>写一下实现合理化<br>你对三大框架的理解是什么<br>前端性能理解，优化有哪些<br>nodejs 了解多少<br>你遇到的最有难度的技术问题是什么<br>redux 原理讲讲<br>了解 web 移动开发吗，移动端适配方案有哪些<br>你有 Native 开发经验吗，讲下 Android 如何调用页面的资源<br>行内元素和块级元素有哪些，img 属于什么元素<br>margin 坍塌<br>BFC 原理<br>写一下清除浮动<br>写一下不知道宽高元素垂直水平居中方法<br>写一下节点的增删改<br>如何获取元素的父节点和兄弟节点<br>JS 如何获得用户来源（navigator.userAgent）<br>跨域方法说一下<br>jsonp 的原理是什么，处理 script 标签还可以通过什么实现？（静态资源标签）<br>原型链说一下<br>谈谈对原型链继承<br>前端缓存<br>给你一个乱序数组，你怎么样排序<br>你的项目有什么亮点<br>你的文件上传方案是什么<br>写一个方法提取一下 search 里面的参数<br>写一个 API 实现 insertAfter<br>CSS3 哪些用的比较多<br>CSS 动画会吗，怎么样用 CSS 实现一个 loading 效果<br>如何处理 CSS 兼容问题<br>webpack 有个插件可以解决 css 兼容性问题你知道吗（postcss-loader）<br>ES6 新特性说说<br>ES6 的代理是什么<br>let 和 var 的区别讲讲<br>箭头函数和 ES5 和 this 的指向区别讲讲<br>前端安全这块了解多少<br>写一个 API，实现 jQuery 的$(selector)选择器，要求兼容 IE6<br>浏览器是如何实现通过你的代码去找到指定的元素的<br>用 JS 模拟一个双向链表<br>前端工程化思想<br>模块化思想<br>你为什么选择前端<br>cookie，session，localStorage 和 sessionStorage 的区别<br>Nodejs 的线程管理<br>JS 设计模式有哪些<br>跨域的方法有哪些<br>说说 bind，apply，call 的区别以及 bind 的实现<br>算法：反转二叉树以及时间复杂度<br>链表找环<br>react 的 virtual DOM 和 Diff 算法<br>React 的生命周期<br>Vue 的生命周期<br>boostrap 的底层原理<br>图片压缩的原理<br>如何处理高并发的情况下，用户顺序问题<br>说一下 web 安全，xss，csrf 防范<br>csrf 流程，举例子<br>session+cookie 的登录机制<br>token 香港，浏览器缓存<br>vue 双向绑定原理，vue-loader 做了什么<br>webpack 的插件大致流程<br>编程题：给出一个字符串(“obj.a”)，返回对象属性 obj.a，类似 eval 的效果<br>前端路由会不会发请求<br>画布濡染有了解吗<br>前端监控，pm2，如果我服务器挂了，如何快速发现并且定位错误<br>pm2 除了监控还能干什么，如何实现<br>express 中间件如何实现<br>了解 TCP 吗，数据结构简单介绍一下以及你的想法<br>webpack 项目太大了怎么办<br>深拷贝<br>如果弹出的菜单位置过于贴近边框，如何调整这个元素的位置<br>计算 50 个人至少有 2 个生日相同的概率<br>一个升序数组，求两个元素的和为一个指定数<br>vue 的生命周期<br>vuex 的状态管理的原理是什么<br>如何在浏览器端和原生端的代码复用，讲到 weex 又简单讲了它的原理<br>跨域如何解决<br>前端性能优化问题<br>csrf 攻击原理以及防御手段<br>平衡二叉树<br>如何在上亿规模的数据中找到最大的一个数<br>最近看过的技术文章和一遍非技术文章（考察表达能力，和主动学习新知识的习惯）<br>算法题：二叉树层序遍历<br>JS 的全排列<br>get 和 post 的区别<br>301 和 302 的区别<br>如何避免 301 跳转 https<br>tcp 建立连接三次握手的区别<br>操作系统进程和线程的区别<br>线程的哪些资源共享，哪些资源不共享<br>设计模式有哪些<br>Linux 命令用的多吗，怎么样进行进程间通信<br>kill 指令了解过吗<br>如何画一个三角形<br>CSS 中对溢出的处理<br>CSS 选择器有哪些，优先级呢？<br>ES6 中用过什么<br>promise 的状态有哪些<br>讲讲 JS 的闭包<br>你有用到 express 吗<br>express 和 koa2 的区别<br>讲讲 JS 的语言特性吗<br>最近在学啥<br>项目用到 JAVA，反射来讲<br>你用过什么数据库<br>MySQL 里面的索引用过吗<br>B+树了解过吗<br>mongoDB 有哪些特点<br>实现一个两列等高布局，思路<br>清除浮动的方法<br>如何让一个元素消失<br>重排和重绘<br>HTTP 状态码<br>讲讲 304<br>浏览器缓存机制<br>强缓存，协商缓存什么时候用哪个<br>如何判断一个数组<br>你说到 typeof，能不能加一个限制条件 typeof 只能判断是 object，可以判断一下是否拥有数组的方法<br>JS 的如何实现倒计时，为什么不准，校正方式<br>JS 实现跨域<br>React 的特性<br>nodejs 的时间方法讲讲看<br>nodejs 的特性，适合处理什么场景<br>IO 多路复用<br>前端优化<br>实现一个 ajax，兼容<br>如何有一个很多的列表，像头条的新闻列表，用户看得多了，列表越来越大，怎么样处理，思考一下<br>如果有这样的场景：一个模块 A 作为输出，BCD 等扩展模块可以在 A 做更改后展示 A 的原来内容或者驾驶 CSS 后的内容，想想思路<br>同一个网站，在上海打开慢，在北京打开快，怎么样分析原因，（DNS 解析和 CDN）<br>vue react jquery 比较，有测试过性能吗<br>对大前端的理解，前端会发展怎么样<br>算法：两个排序好的数组，怎么样找他的中位数<br>React 虚拟 DOM，生命周期<br>react 父子通信<br>nodejs 如何 require 一个包<br>es6 和 es5 的区别<br>Nodejs 加载原生的包与自己定义的包路径如何查找<br>HTTP2.0 的优势<br>flex 弹性布局裂解，移动端适配方案有哪些<br>页面缓存<br>页面性能优化<br>css 性能优化，就动画效果，如何从 js，cs 角度减少回流？<br>webpack 的 plugin 和 loader 的区别<br>es5 如何转为 es5-babel<br>了解 webpack 如何打败<br>原型基础<br>BFC<br>原型链与作用域链<br>jQuery 的源码看过没<br>移动端开发经验<br>css 会吗<br>怎么样学前端<br>遇到问题如何解决<br>正则如何将一个数千分化表示<br>js 设计模式知道哪些，单例详细说<br>函数式编程-柯里化<br>es6 的变量定义和 es5 的区别<br>JS 事件流<br>七层网络协议，每层干嘛的<br>tcp 三次握手，四次挥手<br>排序算法有哪些，时间复杂度，选择排序怎么样搞<br>数据结构有哪些，红黑树和二叉树的区别，二叉搜索树与二叉平衡树<br>项目经验<br>树数据多少非常多怎么样办（懒加载）<br>页面优化方法<br>设计模式<br>cookie 和 session 的却别<br>如果现在重新做这个项目，有什么想优化的<br>多长时间开始独立做前端，这段时间是如何学习的<br>学习生涯最失败的事情是什么，怎么样走出来的<br>如何看待竞争<br>项目里最难的事情，如何克服<br>职业规范是怎么样的<br>是独生子女吗<br>别人对你的项目认可度，项目做的怎么样<br>block 元素和 inline 元素的区别<br>position 有哪些，特性<br>css 选择器有哪些<br>es5 和 es6：let，const 打包后如何变-块级作用域<br>JS 基本数据类型<br>作用域链<br>递归<br>react 生命周期<br>react 通信机制<br>js 事件流<br>redux<br>flex 弹性布局<br>this<br>promise 如何从 then 转为 catch 的<br>介绍你做过的项目<br>promise 函数<br>es6 模块新特性<br>浏览器内存泄露，闭包内存泄露如何解决<br>怎么样让页面加载更快<br>兼容过 IE 的方法<br>缓存<br>会 pc 换还是移动端<br>观察者模式如何实现<br>行元素，块级元素的却别<br>css 选择器的优先级<br>水平垂直居中布局<br>前端性能优化<br>闭包的概念，平时如何实现<br>es6 的特性以及这些特性如何实现的<br>事件冒泡，事件捕获，事件委托的原理，如何实现委托，事件，委托的有点是什么，事件监听<br>输入 URL 浏览器是如何工作的<br>requirejs 组件化<br>jQuery 和 vue 的区别<br>vue 的特点<br>vue 的双向绑定原理<br>谈谈 js 设计模式<br>如何实现订阅者发者模式<br>MVVM 实现原理<br>vue 生命周期<br>vue 跨组件通信实现<br>vue 的 props 和 slot 的使用，区别<br>vuex 的原理<br>详细说明解决跨域的方式<br>前端安全（资源枚举，XSS 共计，DOS 攻击，CSRF 攻击）<br>HTTP 状态码<br>重排重绘<br>谈谈 JS 的异步机制<br>项目中是是如何优化页面的<br>如何实现移动端布局，适配方案<br>call apply bind 的区别<br>深拷贝的实现<br>jQuery 原理，平时用 jQuery 都做过什么<br>用过 webpack 吗，谈一下 webpack 打包<br>给了一个 settimeout 代码输出的顺序<br>git 命令<br>Linux 命令<br>JS 基础有几种<br>流式布局<br>对前端的了解和个人规划<br>html5 的新特性<br>float 和 position 的区别<br>如何获取当前日期<br>html 语义化，好处<br>计算器<br>清除浮动<br>盒子模型<br>border-box 和 content-box<br>css 伪元素有哪些<br>打开连接到网页呈现的流程<br>HTTP 请求头，响应头里面有哪些<br>异步加载 JS<br>JS 原型<br>看哪些技术网站<br>觉得自己的不足<br>cookie 实现<br>cookie 长度限制<br>http 状态码<br>301 302<br>性能优化<br>一个网页很多很多页面，怎么样让用户体验好一点<br>一个项目可能要延期，怎么样处理<br>URL 长度限制<br>缓存<br>什么时候用 local，什么时候用 session 和 storage<br>长连接<br>有没有抓过包<br>有没有用过代理<br>DNS<br>图片压缩<br>gzip<br>浏览器兼容<br>webpack css 兼容<br>css 性能<br>垂直居中，水平居中<br>盒子米线<br>last-modifined，etg 怎么样判断<br>css 动画优化<br>401 状态码<br>reflow 和 repaint<br>应用层协议有哪些<br>TCP 和 UDP<br>有哪些状态码<br>Ajax 如何实现的<br>Ajax 返回 204 算是成功吗<br>settimeout 异步<br>tcp ip 分成<br>vue diff 算法<br>vue 的生命周期<br>pwa<br>vue-router 不能解决情况和边界情况<br>transition 生命周期<br>线程和进程的区别<br>什么是异步<br>promise 是如何解析异步操作的<br>如果给 a,b,c,d 四个时间，执行时间分别为 1，2，3，4，怎么样做才能在 abc 都在执行完后再执行 d，除了使用 promise 还能使用什么方法<br>数组去重方法<br>函数节流和函数防抖知道吗，区别是什么<br>TCP 和 UDP 的区别<br>HTTP1.0 和 HTTP1.1 相关我让你听<br>强缓存和协商缓存知道吗<br>为什么 HTTP1.1 中使用 Cache-Control 代替 Expires<br>HTTP1.1 中 Etg 和 f-None-Match 哪个权重比较大<br>排序的几种方法知道吗，是如何实现的<br>栈和队列有什么区别，具体的应用场景<br>hashmap 原理<br>react 中 props 和 state 的区别<br>组件怎么样拿到 redux 的数据<br>给你一个 DOM 元素，用 CSS 的方式让他呈现两个的想过，只有一个 DOM 元素<br>一个数组只有 1 和 2，排序，1 在前面，2 在后面<br>js 事件模型，捕获和冒泡，阻止冒泡<br>preventDefault 和 stopPropagation 的区别<br>HTTP 缓存<br>https<br>react 的事件绑定和原生有什么区别吗<br>一个数组，有很多数字存在 2 次，只有一个数字寸一次，怎么样找出这个数字<br>关于 iframe 内部和外部变量的读取是如何的<br>前端防连击 throttle 和 debounce<br>ES6 generator async&#x2F;await 了解吗<br>HTTP&#x2F;2 有什么新特性<br>哈希的原理<br>如何反转链表<br>二叉搜索树的原理<br>给定两个文本文件，找出他们中相同的行都有哪些<br>对 JS 单线程的理解<br>页面共享数据的方法有哪些<br>amd，cmd 规范<br>用户页面打开很慢，有哪些优化方式<br>react 的虚拟 DOM 了解什么，这些类型的框架和传统的 jd 操作 dom 的优势<br>koa generator 能讲一下吗<br>如何做单侧，单侧和开发占比应该是多少<br>hybrid<br>v-model 参数<br>mvvm，mvc，mvp 区别<br>cdn<br>网络安全 xss，csfr 是什么，怎么样解决安全<br>https 怎么样校验证书有效性<br>websocket 协议，nodejs 中有哪些实现了这个协议<br>TCP&#x2F;IP 体系结构以及每层的主要协议<br>TCP 的三次握手<br>HTTP 各版本比较<br>数据结构学过什么<br>js 如何实现一个栈<br>哈希表是怎么样的结构<br>说说操作系统的内存管理<br>怎么样实现一个服务器<br>如何删除一个 dom 节点<br>浏览器如何渲染页面的<br>GitHub 的项目问<br>看过什么书<br>你是如何理解 HTML 语义化的<br>HTML 的黑钻模型有哪些构成的，盒子模型有哪些，默认是哪些<br>盒子模型有没有办法把宽度设置为包含 padding<br>浮动元素有没有什么特性<br>清除浮动的所有方法<br>ji 基本数据类型<br>typeof 去判断数据类型返回值有哪些<br>说说事件代理利用的是什么原理<br>阻止冒泡的函数是什么<br>cookie 有什么特征<br>加入访问 A.com 存进了一个 cookie，在另外一个页面用 ajax 向 A 的域名发请求会携带 cookie 吗<br>cookie 的其他解决方案<br>localStorage 存储数据格式是什么<br>怎么样把一个数组存进 localSorage<br>storage 有哪些存储方法<br>html5 有哪些新的特性<br>假设两台电脑之间同步画板如何实现<br>promise 的两个方法，具体实现<br>es6 用的多的有哪些<br>箭头函数<br>如果一个页面做辛夷花，从哪些方面考察，从哪些地方优化<br>vue 开发模式和 jQuery 模式有哪些不同，有哪些优缺点<br>假设一个 object A 里面的值 n 为 1，怎么样知道 n 改变了，有事件绑定吗<br>react 是如何实现数据绑定的<br>给数字加千位分隔符<br>HTTP1 SPDY HTTP2 的对比<br>webkit 内核渲染页面过程<br>简单介绍一下 backbone<br>react 首次渲染过程<br>redux 和 vuex 的区别<br>了解过 weex 吗<br>typescript 和 es6 的区别<br>知道 xss 吗，介绍一下，如何避免<br>跨域方式<br>如何理解 html 语义化<br>浏览器如何处理未知的的 tab<br>html5 有什么新的 tag，canvas…<br>nodejs 的优势，用过 nodejs 的哪些模块<br>预约系统如何解决高并发的问题<br>kut 如何优化 react 的 diff，有去提 pr 吗，为什么<br>简单说一下 ICP UDP<br>Socks5 代理是如何实现的，读过协议吗<br>http 状态码，307 是什么，401 和 403 的区别<br>酸酸是如何实现穿墙的<br>如何实现文件上传的功能<br>垂直居中的实现<br>react 和 vue 的区别<br>介绍一下盒子模型<br>实现 css 动画有哪些<br>jsonp 如何实现，过程<br>知道哪些 http 状态码<br>200 和 304 实现缓存的区别<br>localstorage 和 cookie 的区别，如何设置 cookie<br>表单提交和 ajax 的区别<br>calc 属性<br>symbol<br>事件监听<br>常见的请求方式<br>tcp 和 http 的区别<br>css 的定位属性，怎么样定位的<br>情景题：给你一个 ul 列表，找到点击的 li 对象，把点击到的对象的字符串翻转，讲出思路并且写出代码<br>只能用获取到对象的属性<br>小程序的生命周期<br>小程序的 Onlaunch 周期不支持同步获取信息之后再执行到下一个生命周期<br>你怎么样维持用户登录状态的<br>给你一颗树，如何找到其公共的父节点<br>你最荣耀的事情<br>你怎么样知道我们公司的，为什么来我们公司<br>rem，px，em 的区别<br>协同开发需要注意什么</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/07/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cltzhcydi001fzoxh45tf1kt2" data-title="常见知识点链接" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/" rel="tag">js</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-HTTP面试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/12/HTTP%E9%9D%A2%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2019-10-12T01:01:18.000Z" itemprop="datePublished">2019-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/12/HTTP%E9%9D%A2%E8%AF%95/">http</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="http-methods-有那些"><a href="#http-methods-有那些" class="headerlink" title="http methods 有那些"></a>http methods 有那些</h3><blockquote>
<p>1.get:获取资源<br>2.head：获取报文头部<br>3.post:传输实体主体，用来给服务器发送数据<br>4.put:传输文件<br>5.delete 删除文件,即删除按请求 URI 下的指定资源<br>6.options:询问支持方法，，则它会在 HTTP 头中包含一个名为“Allow”的头，值便是所支持的方法，如“GET、POST”。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/12/HTTP%E9%9D%A2%E8%AF%95/" data-id="cltzhcyd20006zoxhetgjaljy" data-title="http" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/css%E9%9D%A2%E8%AF%95/">css面试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gis/">gis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9E%B6%E6%9E%84/">架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/cesium/" rel="tag">cesium</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css%E9%9D%A2%E8%AF%95/" rel="tag">css面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es/" rel="tag">es</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gis/" rel="tag">gis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/cesium/" style="font-size: 10px;">cesium</a> <a href="/tags/css%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">css面试</a> <a href="/tags/es/" style="font-size: 10px;">es</a> <a href="/tags/gis/" style="font-size: 10px;">gis</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/react/" style="font-size: 10px;">react</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 10px;">工程化</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">架构</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 20px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/03/20/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/12/06/mapbox%E5%9F%BA%E7%A1%80/">基础</a>
          </li>
        
          <li>
            <a href="/2021/04/01/es%206%207%208%209/">es6 7 8</a>
          </li>
        
          <li>
            <a href="/2021/04/01/cesuim/Viewer/">cesium viewer</a>
          </li>
        
          <li>
            <a href="/2021/03/02/css%E9%9D%A2%E8%AF%95/">css面试</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>